#!/usr/bin/env bash
set -o nounset -o pipefail -o errexit

# look - Observe what the user is currently viewing
#
# Part of the show-and-tell package for visual context sharing
# between AI assistants and users.

VERSION="1.0.0"

show_help() {
  cat <<EOF
Usage: look [OPTIONS] [TARGET]

Observe what the user is currently viewing.

Targets:
  (none)                   Current pane content
  %<id>                    Specific pane by ID
  %1,%2,%3                 Multiple panes (comma-separated)
  window                   All panes in current window
  <session>:<window>       All panes in specific window

Options:
  -l, --lines N            Lines of scrollback history (default: visible)
  -H, --hierarchy          Show tmux hierarchy only (no content)
  -p, --preserve-blanks    Preserve exact blank line spacing
  -h, --help               Show this help
  -V, --version            Show version

Examples:
  look                      # Current pane content
  look -H                   # Show tmux hierarchy
  look %15                  # Specific pane
  look %15,%16              # Multiple panes
  look window               # All panes in window
  look -l 100               # Last 100 lines of history
  look main:0               # Panes in main session window 0

Output includes:
  - Tmux session/window/pane hierarchy with active indicators
  - Neovim detection with file info via nvim-remote
  - Pane content capture
  - Sensitive content warnings (passwords, API keys, etc.)

EOF
}

# Get tmux hierarchy as formatted text
get_tmux_hierarchy() {
  local current_session current_window current_pane

  # Get current location
  if ! current_session=$(tmux display-message -p "#{session_name}" 2>/dev/null); then
    echo "Not in tmux"
    return 1
  fi
  current_window=$(tmux display-message -p "#{window_index}" 2>/dev/null)
  current_pane=$(tmux display-message -p "#{pane_id}" 2>/dev/null)

  echo "Tmux summary:"

  # List sessions
  while IFS=: read -r session windows attached; do
    local prefix="  "
    [[ "$session" == "$current_session" ]] && prefix="â†’ "

    local window_list=""
    local first=true

    # Get windows for this session
    while IFS=: read -r win_idx win_name win_panes win_active; do
      [[ -z "$win_idx" ]] && continue

      # Get pane IDs for this window
      local pane_ids
      pane_ids=$(tmux list-panes -t "${session}:${win_idx}" -F "#{pane_id}" 2>/dev/null | tr '\n' ' ' | sed 's/ $//')

      local win_str="${win_name}[${pane_ids:-${win_panes}p}]"

      # Mark active window in current session
      if [[ "$session" == "$current_session" && "$win_active" == "1" ]]; then
        win_str="*${win_str}"
      fi

      if $first; then
        window_list="$win_str"
        first=false
      else
        window_list="${window_list}, ${win_str}"
      fi
    done < <(tmux list-windows -t "$session" -F "#{window_index}:#{window_name}:#{window_panes}:#{window_active}" 2>/dev/null)

    local attach_str=""
    [[ "$attached" == "1" ]] && attach_str=" (attached)"

    echo "${prefix}${session}: ${window_list}${attach_str}"
  done < <(tmux list-sessions -F "#{session_name}:#{session_windows}:#{session_attached}" 2>/dev/null)

  echo "  (in ${current_session}:${current_window} pane ${current_pane})"
}

# Check if Neovim is running in a pane
check_neovim_in_pane() {
  local pane_id="$1"
  local command
  command=$(tmux display-message -t "$pane_id" -p "#{pane_current_command}" 2>/dev/null)
  [[ "$command" == *nvim* || "$command" == *vim* ]]
}

# Get Neovim info via socket
get_neovim_info() {
  local pane_id="$1"
  local numeric_id="${pane_id#%}"
  local socket_path="/tmp/nvim-tmux-pane-${numeric_id}"

  # Check if socket exists
  if [[ ! -S "$socket_path" ]]; then
    return 1
  fi

  # Try nvim-remote status if available
  if command -v nvim-remote >/dev/null 2>&1; then
    nvim-remote -s "$socket_path" status 2>/dev/null && return 0
  fi

  # Fall back to direct nvim commands
  local file line col mode modified

  file=$(nvim --server "$socket_path" --remote-expr "expand('%:p')" 2>/dev/null)
  if [[ -n "$file" ]]; then
    echo "File: ${file:-[No Name]}"

    line=$(nvim --server "$socket_path" --remote-expr "line('.')" 2>/dev/null)
    col=$(nvim --server "$socket_path" --remote-expr "col('.')" 2>/dev/null)
    mode=$(nvim --server "$socket_path" --remote-expr "mode()" 2>/dev/null)
    modified=$(nvim --server "$socket_path" --remote-expr "&modified" 2>/dev/null)

    echo "Position: line $line, column $col"
    echo "Mode: $mode"
    [[ "$modified" == "1" ]] && echo "Modified: yes (unsaved changes)"

    return 0
  fi

  return 1
}

# Check for sensitive content patterns
check_sensitive_content() {
  local content="$1"

  # Simple pattern matching for common sensitive data
  # Note: Using '"'"' to include literal single quote in pattern
  # Using -- to ensure patterns aren't interpreted as options
  if echo "$content" | grep -qiE -- '(password|api[_-]?key|secret|token)["'"'"']?\s*[:=]'; then
    return 0
  fi

  # Long uppercase strings (potential API keys)
  if echo "$content" | grep -qE -- '\b[A-Z0-9]{20,}\b'; then
    return 0
  fi

  # Private keys
  if echo "$content" | grep -q -- '-----BEGIN.*PRIVATE KEY'; then
    return 0
  fi

  return 1
}

# Compress multiple blank lines
compress_blank_lines() {
  local content="$1"
  local max="${2:-2}"

  # Remove trailing whitespace and compress blank lines
  echo "$content" | sed 's/[[:space:]]*$//' | awk -v max="$max" '
    /^$/ { blank++; next }
    { if (blank > 0) { for (i=0; i<(blank>max?max:blank); i++) print ""; blank=0 } print }
    END { if (blank > 0) for (i=0; i<(blank>max?max:blank); i++) print "" }
  '
}

# Capture content from a pane
capture_pane_content() {
  local pane_id="$1"
  local lines="${2:-}"
  local preserve_blanks="${3:-false}"

  local cmd=(tmux capture-pane -t "$pane_id" -p)

  if [[ -n "$lines" ]]; then
    cmd+=(-S "-${lines}")
  fi

  local content
  if ! content=$("${cmd[@]}" 2>/dev/null); then
    echo "Error: Failed to capture pane $pane_id" >&2
    return 1
  fi

  # Compress blank lines unless preserving
  if [[ "$preserve_blanks" != "true" ]]; then
    content=$(compress_blank_lines "$content")
    # Trim leading and trailing blank lines (portable - no tac)
    content=$(echo "$content" | sed -e 's/^[[:space:]]*$//' | awk '
      /[^[:space:]]/ { found=1 }
      found { lines[++n] = $0 }
      END {
        for (i=n; i>=1; i--) if (lines[i] ~ /[^[:space:]]/) { last=i; break }
        for (i=1; i<=last; i++) print lines[i]
      }
    ')
  fi

  echo "$content"
}

# Get list of panes to capture based on target
get_panes_to_capture() {
  local target="${1:-}"

  if [[ -z "$target" ]]; then
    # Current pane
    tmux display-message -p "#{pane_id}" 2>/dev/null
    return
  fi

  if [[ "$target" == *,* ]]; then
    # Multiple panes (comma-separated)
    echo "$target" | tr ',' '\n'
    return
  fi

  if [[ "$target" == "window" ]]; then
    # All panes in current window
    tmux list-panes -F "#{pane_id}" 2>/dev/null
    return
  fi

  if [[ "$target" == *:* ]]; then
    # Session:window format
    tmux list-panes -t "$target" -F "#{pane_id}" 2>/dev/null
    return
  fi

  # Single pane ID
  echo "$target"
}

main() {
  local target=""
  local lines=""
  local hierarchy_only=false
  local preserve_blanks=false

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -V|--version)
        echo "look version $VERSION"
        exit 0
        ;;
      -l|--lines)
        lines="$2"
        shift 2
        ;;
      -H|--hierarchy)
        hierarchy_only=true
        shift
        ;;
      -p|--preserve-blanks)
        preserve_blanks=true
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        exit 1
        ;;
      *)
        if [[ -z "$target" ]]; then
          target="$1"
        else
          echo "Error: Multiple targets specified" >&2
          exit 1
        fi
        shift
        ;;
    esac
  done

  # Check if we're in tmux
  if [[ -z "${TMUX:-}" ]]; then
    echo "Not in a tmux session"
    exit 1
  fi

  # Show hierarchy
  get_tmux_hierarchy
  echo ""

  # Exit if hierarchy only
  if $hierarchy_only; then
    exit 0
  fi

  # Get panes to capture
  local panes
  panes=$(get_panes_to_capture "$target")

  if [[ -z "$panes" ]]; then
    echo "No panes to capture"
    exit 0
  fi

  local has_sensitive=false

  # Capture each pane
  while IFS= read -r pane_id; do
    [[ -z "$pane_id" ]] && continue

    # Check for Neovim
    if check_neovim_in_pane "$pane_id"; then
      echo "[Neovim detected in pane $pane_id]"
      if get_neovim_info "$pane_id"; then
        echo "Tip: Use nvim-remote for full editor control"
      else
        # Fallback: show working directory
        local pane_path
        pane_path=$(tmux display-message -t "$pane_id" -p "#{pane_current_path}" 2>/dev/null)
        [[ -n "$pane_path" ]] && echo "Working directory: $pane_path"
      fi
      echo ""
    fi

    # Capture content
    echo "--- Pane $pane_id content ---"
    if [[ -n "$lines" ]]; then
      echo "(Showing last $lines lines of scrollback)"
    else
      echo "(Showing visible screen. Use -l 200 for more history)"
    fi

    local content
    content=$(capture_pane_content "$pane_id" "$lines" "$preserve_blanks")

    if [[ -n "$content" ]]; then
      echo "$content"

      # Check for sensitive content
      if check_sensitive_content "$content"; then
        has_sensitive=true
      fi
    fi

    echo ""
  done <<< "$panes"

  # Sensitive content warning
  if $has_sensitive; then
    echo "Warning: Potential sensitive information detected"
    echo "Consider reviewing before sharing. Use -H to show hierarchy only without content."
  fi
}

# Run if not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
