#!/usr/bin/env bash
set -o nounset -o pipefail -o errexit

# show - Display files, URLs, or command output for the user
#
# Part of the show-and-tell package for visual context sharing
# between AI assistants and users.

VERSION="1.1.0"

# Configuration with defaults
SHOW_SESSION="${SHOW_SESSION:-}"  # Empty = auto-detect current session
SHOW_WINDOW="${SHOW_WINDOW:-show}"
SHOW_BROWSER="${SHOW_BROWSER:-}"  # Empty means auto-detect
SHOW_AUTO_ATTACH="${SHOW_AUTO_ATTACH:-true}"
SHOW_FOCUS="${SHOW_FOCUS:-true}"
SHOW_ZOOM="${SHOW_ZOOM:-true}"

# Get private socket directory for security
# Returns user-private directory instead of world-readable /tmp
get_socket_dir() {
  if [[ -n "${TMPDIR:-}" && -d "$TMPDIR" ]]; then
    echo "$TMPDIR"
  elif [[ -n "${XDG_RUNTIME_DIR:-}" && -d "$XDG_RUNTIME_DIR" ]]; then
    echo "$XDG_RUNTIME_DIR"
  else
    local fallback="$HOME/.local/run"
    mkdir -p "$fallback" && chmod 700 "$fallback"
    echo "$fallback"
  fi
}

# Get target tmux session based on configuration and context
# Priority: 1. Explicit flag, 2. Env var, 3. Current session, 4. Attached, 5. Any, 6. Create
get_target_session() {
  local explicit_session="${1:-}"

  # Priority 1 & 2: Explicit flag or env var (already resolved by caller)
  if [[ -n "$explicit_session" ]]; then
    echo "$explicit_session"
    return 0
  fi

  # Priority 3: Current tmux session (if running inside tmux)
  if [[ -n "${TMUX:-}" ]]; then
    tmux display-message -p '#{session_name}'
    return 0
  fi

  # Priority 4: First attached session (visible to user)
  local attached
  attached=$(tmux list-sessions -F '#{session_name} #{session_attached}' 2>/dev/null \
    | awk '$2 > 0 {print $1; exit}')
  if [[ -n "$attached" ]]; then
    echo "$attached"
    return 0
  fi

  # Priority 5: Any existing session
  local any_session
  any_session=$(tmux list-sessions -F '#{session_name}' 2>/dev/null | head -1)
  if [[ -n "$any_session" ]]; then
    echo "$any_session"
    return 0
  fi

  # Priority 6: Create new session (let tmux name it)
  tmux new-session -d -n "$SHOW_WINDOW" 2>/dev/null
  tmux list-sessions -F '#{session_name}' | head -1
}

show_help() {
  cat <<EOF
Usage: show <target> [OPTIONS]

Display content for the user to view.

Targets:
  <file>                   Open file in Neovim
  <file>:<line>            Open file at specific line
  <file>:<start>-<end>     Open file highlighting line range
  <file>#L<line>           Open file at specific line (URL fragment style)
  <file>#L<start>-<end>    Open file highlighting line range
  http://... https://...   Open URL in browser
  cmd:<command>            Run command in shell pane
  pane:<id>                Focus tmux pane by ID
  window:<index|name>      Switch to tmux window
  w:<pattern>              Switch to window matching pattern

Options:
  -s, --session NAME       Use specific tmux session
  -w, --window NAME        Use specific window name (default: show)
  -p, --pane ID            Target specific pane ID
  --no-focus               Don't switch focus to show window
  --no-zoom                Don't zoom the pane after showing
  --no-attach              Don't auto-attach terminal if no clients
  -h, --help               Show this help
  -V, --version            Show version

Behavior:
  By default, show opens files in the "show" window of your current tmux
  session. If you're not in tmux, it uses an attached session, or creates
  one if none exist.

  Show only connects to Neovim instances it created, using sockets in a
  private directory for security.

Examples:
  show README.md                    # Open in current session's show window
  show -s main README.md            # Open in "main" session
  show -w editor file.txt           # Open in "editor" window
  show src/main.py:42               # Open at line 42
  show src/main.py:10-20            # Open highlighting lines 10-20
  show bin/show#L124-162            # Highlight function definition
  show https://github.com           # Open in browser
  show "cmd:git status"             # Show git status
  show window:2                     # Switch to window 2
  show w:cli                        # Switch to window with 'cli' in name
  show --no-zoom file.txt           # Open without zooming pane

Environment:
  SHOW_SESSION             Target tmux session (default: current/auto-detect)
  SHOW_WINDOW              Target window name (default: show)
  SHOW_BROWSER             Browser for URLs (default: auto-detect)
  SHOW_AUTO_ATTACH         Auto-attach terminal if no clients (default: true)
  SHOW_FOCUS               Switch focus to show window (default: true)
  SHOW_ZOOM                Zoom pane after showing content (default: true)

EOF
}

# Parse file:line or file#Lline format with optional line ranges
# Returns: file_path, start_line, and end_line (empty if no line/range)
parse_file_target() {
  local target="$1"
  local file_path=""
  local start_line=""
  local end_line=""

  # Check for range: #L10-20 format (URL fragment style)
  if [[ "$target" =~ ^(.+)#[Ll]([0-9]+)-([0-9]+)$ ]]; then
    file_path="${BASH_REMATCH[1]}"
    start_line="${BASH_REMATCH[2]}"
    end_line="${BASH_REMATCH[3]}"
  # Check for range: :10-20 format
  elif [[ "$target" =~ ^(.+):([0-9]+)-([0-9]+)$ ]]; then
    file_path="${BASH_REMATCH[1]}"
    start_line="${BASH_REMATCH[2]}"
    end_line="${BASH_REMATCH[3]}"
  # Check for single line: #L format (URL fragment style)
  elif [[ "$target" =~ ^(.+)#[Ll]([0-9]+)$ ]]; then
    file_path="${BASH_REMATCH[1]}"
    start_line="${BASH_REMATCH[2]}"
  # Check for single line: :line format
  elif [[ "$target" =~ ^(.+):([0-9]+)$ ]]; then
    file_path="${BASH_REMATCH[1]}"
    start_line="${BASH_REMATCH[2]}"
  else
    file_path="$target"
  fi

  # Handle file:// prefix
  if [[ "$file_path" =~ ^file://([^/]*)(/.*)$ ]]; then
    file_path="${BASH_REMATCH[2]}"
  fi

  echo "$file_path"
  echo "$start_line"
  echo "$end_line"
}

# Check if a tmux session has any attached clients
session_has_clients() {
  local session="$1"
  local clients
  clients=$(tmux list-clients -t "$session" 2>/dev/null)
  [[ -n "$clients" ]]
}

# Open a new Terminal window and attach to the specified tmux session
open_terminal_for_session() {
  local session="$1"
  local system
  system="$(uname -s)"

  case "$system" in
    Darwin)
      # macOS: Use AppleScript to open Terminal
      osascript -e "
        tell application \"Terminal\"
          do script \"tmux attach-session -t '$session'\"
          activate
        end tell
      " >/dev/null 2>&1
      ;;
    Linux)
      # Linux: Try various terminal emulators
      if command -v gnome-terminal >/dev/null 2>&1; then
        gnome-terminal -- tmux attach-session -t "$session" &
      elif command -v kitty >/dev/null 2>&1; then
        kitty tmux attach-session -t "$session" &
      elif command -v alacritty >/dev/null 2>&1; then
        alacritty -e tmux attach-session -t "$session" &
      elif command -v xterm >/dev/null 2>&1; then
        xterm -e "tmux attach-session -t '$session'" &
      elif command -v konsole >/dev/null 2>&1; then
        konsole -e tmux attach-session -t "$session" &
      else
        echo "Warning: No supported terminal emulator found" >&2
        return 1
      fi
      ;;
    *)
      echo "Warning: Unsupported platform for terminal auto-attach: $system" >&2
      return 1
      ;;
  esac
}

# Get or create the show tmux session and window
get_or_create_show_window() {
  local session="$1"
  local window="$2"

  # Check if session exists
  if ! tmux has-session -t "$session" 2>/dev/null; then
    # Create session with target window
    tmux new-session -d -s "$session" -n "$window"
    echo "Created session: $session" >&2
  fi

  # Check if target window exists in session
  if ! tmux list-windows -t "$session" -F "#{window_name}" | grep -q "^${window}$"; then
    tmux new-window -t "$session" -n "$window"
    echo "Created window: $window" >&2
  fi

  # Auto-attach terminal if session has no clients and auto-attach is enabled
  if [[ "$SHOW_AUTO_ATTACH" == "true" ]] && ! session_has_clients "$session"; then
    open_terminal_for_session "$session"
    # Give terminal time to attach
    sleep 0.5
  fi
}

# Find or create editor pane in show window
get_editor_pane() {
  local session="$1"
  local window="$2"
  local pane_id

  # Get the first pane in the target window
  pane_id=$(tmux list-panes -t "${session}:${window}" -F "#{pane_id}" 2>/dev/null | head -1)

  if [[ -z "$pane_id" ]]; then
    echo "Error: Could not find pane in ${session}:${window}" >&2
    return 1
  fi

  echo "$pane_id"
}

# Wait for Neovim socket to become available
# Args: socket_path, max_attempts (default 15), delay_ms (default 200)
# Returns: 0 if socket ready, 1 if timeout
wait_for_nvim_socket() {
  local socket_path="$1"
  local max_attempts="${2:-15}"  # 15 * 0.2s = 3 seconds max
  local delay="${3:-0.2}"
  local attempt=0

  while [[ $attempt -lt $max_attempts ]]; do
    if [[ -S "$socket_path" ]]; then
      # Socket exists, verify it's responding
      if nvim --server "$socket_path" --remote-expr "1" >/dev/null 2>&1; then
        return 0
      fi
    fi
    sleep "$delay"
    ((attempt++))
  done

  return 1
}

# Find or create shell pane in show window
get_shell_pane() {
  local session="$1"
  local window="$2"
  local panes

  # Count panes in target window
  panes=$(tmux list-panes -t "${session}:${window}" -F "#{pane_id}" 2>/dev/null | wc -l | tr -d ' ')

  if [[ "$panes" -lt 2 ]]; then
    # Split to create shell pane
    tmux split-window -t "${session}:${window}" -v -p 20
  fi

  # Get the second (bottom) pane
  tmux list-panes -t "${session}:${window}" -F "#{pane_id}" 2>/dev/null | tail -1
}

# Open file in Neovim
handle_file() {
  local target="$1"
  local session="$2"
  local window="$3"
  local explicit_pane="${4:-}"

  # Parse file and line number/range
  local parsed
  parsed=$(parse_file_target "$target")
  local file_path
  local start_line
  local end_line
  file_path=$(echo "$parsed" | sed -n '1p')
  start_line=$(echo "$parsed" | sed -n '2p')
  end_line=$(echo "$parsed" | sed -n '3p')

  # Resolve to absolute path
  if [[ ! "$file_path" =~ ^/ ]]; then
    file_path="$(pwd)/$file_path"
  fi
  file_path=$(realpath "$file_path" 2>/dev/null || echo "$file_path")

  # Verify file exists
  if [[ ! -f "$file_path" ]]; then
    echo "Error: File not found: $file_path" >&2
    return 1
  fi

  # Ensure session and window exist
  get_or_create_show_window "$session" "$window"

  local pane_id
  if [[ -n "$explicit_pane" ]]; then
    pane_id="$explicit_pane"
  else
    pane_id=$(get_editor_pane "$session" "$window")
  fi

  # Socket path in private directory
  local socket_dir
  socket_dir=$(get_socket_dir)
  local socket_path="${socket_dir}/nvim-show-pane-${pane_id#%}"

  if [[ -S "$socket_path" ]]; then
    # Socket exists, wait for it to be responsive (may have just started)
    if wait_for_nvim_socket "$socket_path" 5 0.2; then
      # Neovim running and responsive, open file remotely
      nvim --server "$socket_path" --remote "$file_path" 2>/dev/null

      if [[ -n "$end_line" && "$end_line" =~ ^[0-9]+$ ]]; then
        # Line range: use visual line mode to highlight
        nvim --server "$socket_path" --remote-send ":${start_line}<CR>V${end_line}G" 2>/dev/null
        echo "Opened $file_path highlighting lines $start_line-$end_line in ${session}:${window}"
      elif [[ -n "$start_line" && "$start_line" =~ ^[0-9]+$ ]]; then
        # Single line: jump to line
        nvim --server "$socket_path" --remote-send ":${start_line}<CR>" 2>/dev/null
        echo "Opened $file_path at line $start_line in ${session}:${window}"
      else
        # No line number
        echo "Opened $file_path in ${session}:${window}"
      fi
    else
      echo "Error: Neovim socket exists but not responding: $socket_path" >&2
      return 1
    fi
  else
    # Start neovim in pane
    local nvim_cmd="nvim --listen '$socket_path' '$file_path'"
    tmux send-keys -t "$pane_id" "$nvim_cmd" Enter

    # Wait for Neovim to start and socket to become available
    if wait_for_nvim_socket "$socket_path"; then
      # Socket ready, now jump to line/range if specified
      if [[ -n "$end_line" && "$end_line" =~ ^[0-9]+$ ]]; then
        # Line range: use visual line mode to highlight
        nvim --server "$socket_path" --remote-send ":${start_line}<CR>V${end_line}G" 2>/dev/null
        echo "Opened $file_path highlighting lines $start_line-$end_line in ${session}:${window}"
      elif [[ -n "$start_line" && "$start_line" =~ ^[0-9]+$ ]]; then
        # Single line: jump to line
        nvim --server "$socket_path" --remote-send ":${start_line}<CR>" 2>/dev/null
        echo "Opened $file_path at line $start_line in ${session}:${window}"
      else
        # No line number
        echo "Opened $file_path in ${session}:${window}"
      fi
    else
      # Socket didn't become available, but Neovim might still work
      echo "Started Neovim with $file_path in ${session}:${window} (socket startup slow)"
    fi
  fi

  # Focus the pane if enabled
  if [[ "$SHOW_FOCUS" == "true" ]]; then
    tmux select-window -t "${session}:${window}" 2>/dev/null
    tmux select-pane -t "$pane_id" 2>/dev/null
  fi

  # Zoom the pane if enabled
  if [[ "$SHOW_ZOOM" == "true" ]]; then
    # Only zoom if not already zoomed
    local is_zoomed
    is_zoomed=$(tmux display-message -t "$pane_id" -p '#{window_zoomed_flag}' 2>/dev/null)
    if [[ "$is_zoomed" != "1" ]]; then
      tmux resize-pane -t "$pane_id" -Z 2>/dev/null
    fi
  fi
}

# Open URL in browser
handle_url() {
  local url="$1"

  # Ensure URL has scheme
  if [[ ! "$url" =~ ^https?:// ]]; then
    url="https://$url"
  fi

  # Use configured browser if set
  if [[ -n "$SHOW_BROWSER" ]]; then
    case "$(uname -s)" in
      Darwin)
        open -a "$SHOW_BROWSER" "$url" 2>/dev/null || {
          echo "Error: Could not open with browser: $SHOW_BROWSER" >&2
          return 1
        }
        ;;
      Linux)
        "$SHOW_BROWSER" "$url" 2>/dev/null &
        ;;
    esac
    echo "Opened $url in $SHOW_BROWSER"
    return 0
  fi

  # Auto-detect browser based on OS
  case "$(uname -s)" in
    Darwin)
      # macOS: Try Firefox first, fall back to default browser
      if command -v firefox >/dev/null 2>&1 || [[ -d "/Applications/Firefox.app" ]]; then
        open -a Firefox "$url" 2>/dev/null || open "$url"
      else
        open "$url"
      fi
      ;;
    Linux)
      # Linux: Use xdg-open or firefox
      if command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$url" 2>/dev/null &
      elif command -v firefox >/dev/null 2>&1; then
        firefox "$url" 2>/dev/null &
      else
        echo "Error: No browser found" >&2
        return 1
      fi
      ;;
    *)
      echo "Error: Unsupported platform: $(uname -s)" >&2
      return 1
      ;;
  esac

  echo "Opened $url in browser"
}

# Run command in shell pane
handle_command() {
  local command="$1"
  local session="$2"
  local window="$3"
  local explicit_pane="${4:-}"

  # Remove cmd: or command: prefix
  command="${command#cmd:}"
  command="${command#command:}"

  local pane_id
  if [[ -n "$explicit_pane" ]]; then
    pane_id="$explicit_pane"
  else
    get_or_create_show_window "$session" "$window"
    pane_id=$(get_shell_pane "$session" "$window")
  fi

  # Send command to pane
  tmux send-keys -t "$pane_id" "$command" Enter

  # Focus the pane if enabled
  if [[ "$SHOW_FOCUS" == "true" ]]; then
    tmux select-window -t "${session}:${window}" 2>/dev/null
    tmux select-pane -t "$pane_id" 2>/dev/null
  fi

  echo "Executed: $command in ${session}:${window}"
}

# Focus a tmux pane
handle_pane() {
  local pane_spec="$1"

  # Remove pane: prefix
  pane_spec="${pane_spec#pane:}"

  # Add % prefix if needed
  if [[ ! "$pane_spec" =~ ^% ]]; then
    pane_spec="%$pane_spec"
  fi

  # Verify pane exists
  if ! tmux list-panes -a -F "#{pane_id}" | grep -q "^${pane_spec}$"; then
    echo "Error: Pane not found: $pane_spec" >&2
    return 1
  fi

  # Get window for pane
  local window_id
  window_id=$(tmux list-panes -a -F "#{pane_id} #{window_id}" | grep "^${pane_spec} " | cut -d' ' -f2)

  # Select window and pane
  tmux select-window -t "$window_id" 2>/dev/null
  tmux select-pane -t "$pane_spec" 2>/dev/null

  echo "Focused pane $pane_spec"
}

# Handle window switching
handle_window() {
  local target="$1"
  local session="$2"

  # Remove window: or w: prefix if present
  if [[ "$target" =~ ^window:(.+)$ ]]; then
    target="${BASH_REMATCH[1]}"
  elif [[ "$target" =~ ^w:(.+)$ ]]; then
    # For w: prefix, search for pattern match
    local pattern="${BASH_REMATCH[1]}"
    local matched_window
    matched_window=$(tmux list-windows -t "$session" -F "#{window_index} #{window_name}" 2>/dev/null \
      | grep -i "$pattern" | head -1 | awk '{print $1}')

    if [[ -z "$matched_window" ]]; then
      echo "Error: No window matching '$pattern' found in session $session" >&2
      return 1
    fi
    target="$matched_window"
  fi

  # Switch to the window
  if tmux select-window -t "${session}:${target}" 2>/dev/null; then
    # Get the window name for feedback
    local window_name
    window_name=$(tmux display-message -t "${session}:${target}" -p "#{window_name}" 2>/dev/null)
    echo "Switched to window '${window_name}' in session ${session}"
    return 0
  else
    echo "Error: Window '${target}' not found in session ${session}" >&2
    return 1
  fi
}

# Detect target type and dispatch to handler
detect_and_handle() {
  local target="$1"
  local session="$2"
  local window="$3"
  local pane="${4:-}"

  # Window switching (window: or w: prefix)
  if [[ "$target" =~ ^(window:|w:) ]]; then
    handle_window "$target" "$session"
    return
  fi

  # URL (http:// or https://)
  if [[ "$target" =~ ^https?:// ]]; then
    handle_url "$target"
    return
  fi

  # Command (cmd: or command: prefix)
  if [[ "$target" =~ ^(cmd|command): ]]; then
    handle_command "$target" "$session" "$window" "$pane"
    return
  fi

  # Pane focus (pane: prefix)
  if [[ "$target" =~ ^pane: ]]; then
    handle_pane "$target"
    return
  fi

  # File URL (file://)
  if [[ "$target" =~ ^file:// ]]; then
    handle_file "$target" "$session" "$window" "$pane"
    return
  fi

  # Domain name (contains dot, no path separator at start)
  if [[ "$target" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,} ]]; then
    handle_url "$target"
    return
  fi

  # Default: treat as file
  handle_file "$target" "$session" "$window" "$pane"
}

main() {
  # Check tmux is available
  if ! command -v tmux >/dev/null 2>&1; then
    cat >&2 <<EOF
tmux is required for show command. Install with:
  macOS:         brew install tmux
  Ubuntu/Debian: sudo apt install tmux
  Fedora:        sudo dnf install tmux
EOF
    exit 1
  fi

  local session=""
  local window=""
  local pane=""
  local target=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -V|--version)
        echo "show version $VERSION"
        exit 0
        ;;
      -s|--session)
        session="$2"
        shift 2
        ;;
      -w|--window)
        window="$2"
        shift 2
        ;;
      -p|--pane)
        pane="$2"
        shift 2
        ;;
      --no-focus)
        SHOW_FOCUS="false"
        shift
        ;;
      --no-zoom)
        SHOW_ZOOM="false"
        shift
        ;;
      --no-attach)
        SHOW_AUTO_ATTACH="false"
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        exit 1
        ;;
      *)
        if [[ -z "$target" ]]; then
          target="$1"
        else
          echo "Error: Multiple targets specified" >&2
          exit 1
        fi
        shift
        ;;
    esac
  done

  if [[ -z "$target" ]]; then
    echo "Error: No target specified" >&2
    echo "Run 'show --help' for usage" >&2
    exit 1
  fi

  # Resolve session: CLI > env var > auto-detect
  if [[ -z "$session" ]]; then
    session=$(get_target_session "$SHOW_SESSION")
  fi

  # Resolve window: CLI > env var > default
  if [[ -z "$window" ]]; then
    window="$SHOW_WINDOW"
  fi

  detect_and_handle "$target" "$session" "$window" "$pane"
}

# Run if not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
