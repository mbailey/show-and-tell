#!/usr/bin/env bash
set -o nounset -o pipefail -o errexit

# show - Display files, URLs, or command output for the user
#
# Part of the show-and-tell package for visual context sharing
# between AI assistants and users.

VERSION="1.0.0"
SHOW_SESSION="${SHOW_SESSION:-show}"
SHOW_BROWSER="${SHOW_BROWSER:-}"  # Empty means auto-detect
SHOW_AUTO_ATTACH="${SHOW_AUTO_ATTACH:-true}"  # Auto-attach terminal if session has no clients

show_help() {
  cat <<EOF
Usage: show <target> [OPTIONS]

Display content for the user to view.

Targets:
  <file>                   Open file in Neovim
  <file>:<line>            Open file at specific line
  <file>#L<line>           Open file at specific line (URL fragment style)
  http://... https://...   Open URL in browser
  cmd:<command>            Run command in shell pane
  pane:<id>                Focus tmux pane by ID

Options:
  -s, --session NAME       Force use of specific tmux session (skips nvim-remote)
  -p, --pane ID            Target specific pane ID
  -h, --help               Show this help
  -V, --version            Show version

Behavior:
  By default, show uses nvim-remote to open files in any available Neovim
  instance. If no Neovim is available, it creates a "show" tmux session.

  Use -s to explicitly specify a session, bypassing nvim-remote auto-detection.
  This is useful when you want content displayed in a dedicated window.

Examples:
  show README.md                    # Open in any available Neovim
  show -s show README.md            # Force use of "show" session
  show src/main.py:42               # Open at line 42
  show src/main.py#L42              # Same (URL fragment style)
  show https://github.com           # Open in browser
  show "cmd:git status"             # Show git status
  show "cmd:ls -la"                 # List files
  show pane:15                      # Focus pane %15

Environment:
  SHOW_SESSION             Default tmux session (default: show)
  SHOW_BROWSER             Browser for URLs (default: auto-detect, prefers Firefox)
  SHOW_AUTO_ATTACH         Auto-attach terminal if session has no clients (default: true)
  NVIM_SOCKET_PATH         Neovim socket for file opening

EOF
}

# Parse file:line or file#Lline format
# Returns: file_path and line_number (empty if no line)
parse_file_target() {
  local target="$1"
  local file_path=""
  local line_number=""

  # Check for #L format (URL fragment style)
  if [[ "$target" =~ ^(.+)#[Ll]([0-9]+)$ ]]; then
    file_path="${BASH_REMATCH[1]}"
    line_number="${BASH_REMATCH[2]}"
  # Check for :line format
  elif [[ "$target" =~ ^(.+):([0-9]+)$ ]]; then
    file_path="${BASH_REMATCH[1]}"
    line_number="${BASH_REMATCH[2]}"
  else
    file_path="$target"
  fi

  # Handle file:// prefix
  if [[ "$file_path" =~ ^file://([^/]*)(/.*)$ ]]; then
    file_path="${BASH_REMATCH[2]}"
  fi

  echo "$file_path"
  echo "$line_number"
}

# Check if a tmux session has any attached clients
session_has_clients() {
  local session="$1"
  local clients
  clients=$(tmux list-clients -t "$session" 2>/dev/null)
  [[ -n "$clients" ]]
}

# Open a new Terminal window and attach to the specified tmux session
open_terminal_for_session() {
  local session="$1"
  local system
  system="$(uname -s)"

  case "$system" in
    Darwin)
      # macOS: Use AppleScript to open Terminal
      osascript -e "
        tell application \"Terminal\"
          do script \"tmux attach-session -t $session\"
          activate
        end tell
      " >/dev/null 2>&1
      ;;
    Linux)
      # Linux: Try various terminal emulators
      if command -v gnome-terminal >/dev/null 2>&1; then
        gnome-terminal -- tmux attach-session -t "$session" &
      elif command -v kitty >/dev/null 2>&1; then
        kitty tmux attach-session -t "$session" &
      elif command -v alacritty >/dev/null 2>&1; then
        alacritty -e tmux attach-session -t "$session" &
      elif command -v xterm >/dev/null 2>&1; then
        xterm -e "tmux attach-session -t $session" &
      elif command -v konsole >/dev/null 2>&1; then
        konsole -e tmux attach-session -t "$session" &
      else
        echo "Warning: No supported terminal emulator found" >&2
        return 1
      fi
      ;;
    *)
      echo "Warning: Unsupported platform for terminal auto-attach: $system" >&2
      return 1
      ;;
  esac
}

# Get or create the show tmux session and window
get_or_create_show_window() {
  local session="$1"
  local created_session=false

  # Check if session exists
  if ! tmux has-session -t "$session" 2>/dev/null; then
    # Create session with show window
    tmux new-session -d -s "$session" -n "show"
    echo "Created session: $session"
    created_session=true
  fi

  # Check if show window exists in session
  if ! tmux list-windows -t "$session" -F "#{window_name}" | grep -q "^show$"; then
    tmux new-window -t "$session" -n "show"
    echo "Created window: show"
  fi

  # Auto-attach terminal if session has no clients and auto-attach is enabled
  if [[ "$SHOW_AUTO_ATTACH" == "true" ]] && ! session_has_clients "$session"; then
    open_terminal_for_session "$session"
    # Give terminal time to attach
    sleep 0.5
  fi
}

# Find or create editor pane in show window
get_editor_pane() {
  local session="$1"
  local pane_id

  # Get the first pane in the show window
  pane_id=$(tmux list-panes -t "${session}:show" -F "#{pane_id}" 2>/dev/null | head -1)

  if [[ -z "$pane_id" ]]; then
    echo "Error: Could not find pane in show window" >&2
    return 1
  fi

  echo "$pane_id"
}

# Wait for Neovim socket to become available
# Args: socket_path, max_attempts (default 15), delay_ms (default 200)
# Returns: 0 if socket ready, 1 if timeout
wait_for_nvim_socket() {
  local socket_path="$1"
  local max_attempts="${2:-15}"  # 15 * 0.2s = 3 seconds max
  local delay="${3:-0.2}"
  local attempt=0

  while [[ $attempt -lt $max_attempts ]]; do
    if [[ -S "$socket_path" ]]; then
      # Socket exists, verify it's responding
      if nvim --server "$socket_path" --remote-expr "1" >/dev/null 2>&1; then
        return 0
      fi
    fi
    sleep "$delay"
    ((attempt++))
  done

  return 1
}

# Find or create shell pane in show window
get_shell_pane() {
  local session="$1"
  local panes

  # Count panes in show window
  panes=$(tmux list-panes -t "${session}:show" -F "#{pane_id}" 2>/dev/null | wc -l | tr -d ' ')

  if [[ "$panes" -lt 2 ]]; then
    # Split to create shell pane
    tmux split-window -t "${session}:show" -v -p 20
  fi

  # Get the second (bottom) pane
  tmux list-panes -t "${session}:show" -F "#{pane_id}" 2>/dev/null | tail -1
}

# Open file in Neovim
handle_file() {
  local target="$1"
  local session="$2"
  local explicit_pane="${3:-}"

  # Parse file and line number
  local parsed
  parsed=$(parse_file_target "$target")
  local file_path
  local line_number
  file_path=$(echo "$parsed" | head -1)
  line_number=$(echo "$parsed" | tail -1)

  # Resolve to absolute path
  if [[ ! "$file_path" =~ ^/ ]]; then
    file_path="$(pwd)/$file_path"
  fi
  file_path=$(realpath "$file_path" 2>/dev/null || echo "$file_path")

  # Verify file exists
  if [[ ! -f "$file_path" ]]; then
    echo "Error: File not found: $file_path" >&2
    return 1
  fi

  # Try to use nvim-remote if available (and session not explicitly specified)
  # When user explicitly specifies -s session, we want to use that session, not nvim-remote's auto-detect
  if command -v nvim-remote >/dev/null 2>&1 && [[ "${SHOW_SESSION_EXPLICIT:-false}" != "true" ]]; then
    local nvim_success=false
    if [[ -n "$line_number" && "$line_number" =~ ^[0-9]+$ ]]; then
      # Suppress nvim-remote output, we provide our own message
      nvim-remote edit "$file_path" "$line_number" >/dev/null 2>&1 && nvim_success=true
    else
      nvim-remote edit "$file_path" >/dev/null 2>&1 && nvim_success=true
    fi

    if [[ "$nvim_success" == "true" ]]; then
      # nvim-remote opened the file somewhere, find out where and ensure visibility
      local nvim_socket nvim_pane nvim_session
      nvim_socket=$(nvim-remote status 2>/dev/null | grep "^Socket:" | cut -d' ' -f2)
      if [[ -n "$nvim_socket" ]]; then
        # Extract pane ID from socket path (e.g., /tmp/nvim-tmux-pane-37 -> 37)
        nvim_pane="${nvim_socket##*-}"
        # Find which session this pane is in
        nvim_session=$(tmux list-panes -a -F "#{pane_id} #{session_name}" 2>/dev/null | grep "^%${nvim_pane} " | cut -d' ' -f2)
        # Auto-attach terminal if that session has no clients
        if [[ -n "$nvim_session" && "$SHOW_AUTO_ATTACH" == "true" ]] && ! session_has_clients "$nvim_session"; then
          open_terminal_for_session "$nvim_session"
        fi
      fi
      if [[ -n "$line_number" && "$line_number" =~ ^[0-9]+$ ]]; then
        echo "Opened $file_path at line $line_number"
      else
        echo "Opened $file_path"
      fi
      return 0
    fi
  fi

  # Fallback: Use tmux show window
  get_or_create_show_window "$session"

  local pane_id
  if [[ -n "$explicit_pane" ]]; then
    pane_id="$explicit_pane"
  else
    pane_id=$(get_editor_pane "$session")
  fi

  # Check if neovim socket exists for this pane
  local socket_path="/tmp/nvim-tmux-pane-${pane_id#%}"

  if [[ -S "$socket_path" ]]; then
    # Socket exists, wait for it to be responsive (may have just started)
    if wait_for_nvim_socket "$socket_path" 5 0.2; then
      # Neovim running and responsive, open file remotely
      if [[ -n "$line_number" && "$line_number" =~ ^[0-9]+$ ]]; then
        nvim --server "$socket_path" --remote "$file_path" 2>/dev/null
        nvim --server "$socket_path" --remote-send ":${line_number}<CR>" 2>/dev/null
        echo "Opened $file_path at line $line_number"
      else
        nvim --server "$socket_path" --remote "$file_path" 2>/dev/null
        echo "Opened $file_path"
      fi
    else
      echo "Error: Neovim socket exists but not responding: $socket_path" >&2
      return 1
    fi
  else
    # Start neovim in pane
    local nvim_cmd="nvim --listen '$socket_path' '$file_path'"
    tmux send-keys -t "$pane_id" "$nvim_cmd" Enter

    # Wait for Neovim to start and socket to become available
    if wait_for_nvim_socket "$socket_path"; then
      # Socket ready, now jump to line if specified
      if [[ -n "$line_number" && "$line_number" =~ ^[0-9]+$ ]]; then
        nvim --server "$socket_path" --remote-send ":${line_number}<CR>" 2>/dev/null
        echo "Opened $file_path at line $line_number"
      else
        echo "Opened $file_path"
      fi
    else
      # Socket didn't become available, but Neovim might still work
      echo "Started Neovim with $file_path (socket startup slow)"
    fi
  fi

  # Focus the pane
  tmux select-window -t "${session}:show" 2>/dev/null
  tmux select-pane -t "$pane_id" 2>/dev/null
}

# Open URL in browser
handle_url() {
  local url="$1"

  # Ensure URL has scheme
  if [[ ! "$url" =~ ^https?:// ]]; then
    url="https://$url"
  fi

  # Use configured browser if set
  if [[ -n "$SHOW_BROWSER" ]]; then
    case "$(uname -s)" in
      Darwin)
        open -a "$SHOW_BROWSER" "$url" 2>/dev/null || {
          echo "Error: Could not open with browser: $SHOW_BROWSER" >&2
          return 1
        }
        ;;
      Linux)
        "$SHOW_BROWSER" "$url" 2>/dev/null &
        ;;
    esac
    echo "Opened $url in $SHOW_BROWSER"
    return 0
  fi

  # Auto-detect browser based on OS
  case "$(uname -s)" in
    Darwin)
      # macOS: Try Firefox first, fall back to default browser
      if command -v firefox >/dev/null 2>&1 || [[ -d "/Applications/Firefox.app" ]]; then
        open -a Firefox "$url" 2>/dev/null || open "$url"
      else
        open "$url"
      fi
      ;;
    Linux)
      # Linux: Use xdg-open or firefox
      if command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$url" 2>/dev/null &
      elif command -v firefox >/dev/null 2>&1; then
        firefox "$url" 2>/dev/null &
      else
        echo "Error: No browser found" >&2
        return 1
      fi
      ;;
    *)
      echo "Error: Unsupported platform: $(uname -s)" >&2
      return 1
      ;;
  esac

  echo "Opened $url in browser"
}

# Run command in shell pane
handle_command() {
  local command="$1"
  local session="$2"
  local explicit_pane="${3:-}"

  # Remove cmd: or command: prefix
  command="${command#cmd:}"
  command="${command#command:}"

  local pane_id
  if [[ -n "$explicit_pane" ]]; then
    pane_id="$explicit_pane"
  else
    get_or_create_show_window "$session"
    pane_id=$(get_shell_pane "$session")
  fi

  # Send command to pane
  tmux send-keys -t "$pane_id" "$command" Enter

  # Focus the pane
  tmux select-window -t "${session}:show" 2>/dev/null
  tmux select-pane -t "$pane_id" 2>/dev/null

  echo "Executed: $command"
}

# Focus a tmux pane
handle_pane() {
  local pane_spec="$1"

  # Remove pane: prefix
  pane_spec="${pane_spec#pane:}"

  # Add % prefix if needed
  if [[ ! "$pane_spec" =~ ^% ]]; then
    pane_spec="%$pane_spec"
  fi

  # Verify pane exists
  if ! tmux list-panes -a -F "#{pane_id}" | grep -q "^${pane_spec}$"; then
    echo "Error: Pane not found: $pane_spec" >&2
    return 1
  fi

  # Get window for pane
  local window_id
  window_id=$(tmux list-panes -a -F "#{pane_id} #{window_id}" | grep "^${pane_spec} " | cut -d' ' -f2)

  # Select window and pane
  tmux select-window -t "$window_id" 2>/dev/null
  tmux select-pane -t "$pane_spec" 2>/dev/null

  echo "Focused pane $pane_spec"
}

# Detect target type and dispatch to handler
detect_and_handle() {
  local target="$1"
  local session="$2"
  local pane="${3:-}"

  # URL (http:// or https://)
  if [[ "$target" =~ ^https?:// ]]; then
    handle_url "$target"
    return
  fi

  # Command (cmd: or command: prefix)
  if [[ "$target" =~ ^(cmd|command): ]]; then
    handle_command "$target" "$session" "$pane"
    return
  fi

  # Pane focus (pane: prefix)
  if [[ "$target" =~ ^pane: ]]; then
    handle_pane "$target"
    return
  fi

  # File URL (file://)
  if [[ "$target" =~ ^file:// ]]; then
    handle_file "$target" "$session" "$pane"
    return
  fi

  # Domain name (contains dot, no path separator at start)
  if [[ "$target" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,} ]]; then
    handle_url "$target"
    return
  fi

  # Default: treat as file
  handle_file "$target" "$session" "$pane"
}

main() {
  local session="$SHOW_SESSION"
  local session_explicit=false
  local pane=""
  local target=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -V|--version)
        echo "show version $VERSION"
        exit 0
        ;;
      -s|--session)
        session="$2"
        session_explicit=true
        shift 2
        ;;
      -p|--pane)
        pane="$2"
        shift 2
        ;;
      -*)
        echo "Unknown option: $1" >&2
        exit 1
        ;;
      *)
        if [[ -z "$target" ]]; then
          target="$1"
        else
          echo "Error: Multiple targets specified" >&2
          exit 1
        fi
        shift
        ;;
    esac
  done

  if [[ -z "$target" ]]; then
    echo "Error: No target specified" >&2
    echo "Run 'show --help' for usage" >&2
    exit 1
  fi

  # Export session_explicit for use in handle_file
  export SHOW_SESSION_EXPLICIT="$session_explicit"

  detect_and_handle "$target" "$session" "$pane"
}

# Run if not sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
